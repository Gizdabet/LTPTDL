# -*- coding: utf-8 -*-
"""ĐỒ ÁN LTPTDL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u0wajBMqdBUXvMJ8EdqT_fVVQLykBI4u

DATASET (CSV): https://drive.google.com/file/d/1WOAWpyH5FoDbVVgxe2apA9yw0sHuFzgW/view?usp=sharing

# Import thư viện
"""

!pip3 install --upgrade matplotlib

##------------------------------------------------------------------------------
## Thư viện
##------------------------------------------------------------------------------
import imageio
import matplotlib.pyplot as plt
import numpy             as np
import pandas            as pd
import pydotplus         as pdp
import scipy.stats       as st
import seaborn           as sbn
import plotly.express    as px
import warnings
warnings.filterwarnings('ignore')

from IPython.display         import Image
from sklearn                 import linear_model, svm, tree
from sklearn.linear_model    import LogisticRegression
from sklearn.metrics         import accuracy_score, mean_squared_error, precision_score, f1_score, recall_score, plot_confusion_matrix
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes     import BernoulliNB, GaussianNB
from sklearn.neighbors       import KNeighborsClassifier
from sklearn.tree            import DecisionTreeClassifier
from scipy.cluster          import hierarchy
from scipy.spatial.distance import cdist
from sklearn.cluster        import KMeans, AgglomerativeClustering
from sklearn.preprocessing  import MinMaxScaler, StandardScaler

import scipy.stats as stats

from google.colab import drive
drive.mount('/content/gdrive')

# Commented out IPython magic to ensure Python compatibility.
import os
colab_dir = '/content/gdrive/My Drive'
my_dir    = '/NHÓM 6 - LTPTDL'
path      = colab_dir + my_dir

# %cd $path

"""# Tiền xử lý (cơ bản)
- xử lí missing values
- phân khoảng Age
- Flight distance -> bay đường dài, bay đường ngắn (tham khảo tài liệu ngoài)
- các biến định tính likert scale: 0 -> 3
- depart + arrive delay minutes: phân 2 khoảng 0-1x, >1x (x tự chọn, nên tham khảo tài liệu ngoài)

## Kiểm tra dữ liệu
"""

##------------------------------------------------------------------------------
## Dữ liệu
##------------------------------------------------------------------------------
data = pd.read_csv('Invistico_Airline.csv')
display(data.head(10), '\n')

from google.colab import drive
drive.mount('/content/drive')

# Xem thông tin chi tiết của các cột => Kiểm tra xem cột nào bị thiếu
print(data.info())

display(data.describe())

"""## Xử lí missing values:"""

print('số gt bị thiếu:\n',len(data)-data.count())

# Nhận xét: Cột 'Arrival Delay in Minutes' có 393 dòng dữ liệu bị thiếu
# Vì những dữ liệu bị thiếu ít nên ta sẽ xóa những dòng đó

data = data.dropna(inplace = False)
data = data.reset_index()
data = data.drop(columns = 'index')
display(data)

"""## Phân thành 2 khoảng của cột Arrival Delay in Minutes:"""

# kiểm tra dao động của thời gian delay khi khách hàng đánh giá là 'satisfied'

df = data[data['satisfaction']=='satisfied']
print('Khoảng thời gian hạ cánh bị dời ít nhất đối với các khách hàng hài lòng:', df['Arrival Delay in Minutes'].min())
print('Khoảng thời gian hạ cánh bị dời nhiều nhất đối với các khách hàng hài lòng:', df['Arrival Delay in Minutes'].max())

# kiểm tra dao động của thời gian delay khi khách hàng đánh giá là 'dissatisfied'

df1 = data[data['satisfaction']=='dissatisfied']
print('Khoảng thời gian hạ cánh bị dời ít nhất đối với các khách hàng không hài lòng:', df1['Arrival Delay in Minutes'].min())
print('Khoảng thời gian hạ cánh bị dời nhiều nhất đối với các khách hàng không hài lòng:', df1['Arrival Delay in Minutes'].max())

# Đếm xem đánh giá của KH 'satisfied' khi không bị delay thời gian hạ cánh

print('Sự hài lòng của KH khi chuyến bay hạ cánh không bị delay:',
      df[df['Arrival Delay in Minutes']==0].shape[0])

# Đếm xem đánh giá của KH 'dissatisfied' khi không bị delay thời gian hạ cánh

print('Sự không hài lòng của KH khi chuyến bay hạ cánh không bị delay:',
      df1[df1['Arrival Delay in Minutes']==0].shape[0])

# Biểu đồ thể hiển mức độ đánh giá của KH khi chuyến bay không bị delay

x = ['satisfied', 'dissatisfied']
y = [df[df['Arrival Delay in Minutes']==0].shape[0], df1[df1['Arrival Delay in Minutes']==0].shape[0]]
sbn.barplot(x, y)
plt.title('Biểu đồ đánh giá sự hài lòng của KH\n khi thời gian hạ cánh không bị delay', color = 'red', fontsize=16)
plt.show()

# Từ biểu đồ trên, nhóm thấy được: nếu thời gian delay dưới 4 tiếng KH sẽ ít dissatisfied hơn
# Nếu nhóm chia thành 2 khoảng từ 0-240 (đơn vị phút) và lớn hơn 241
# Lọc xem trong cột 'Arrival Delay in Minutes' có bao nhiêu giá trị chính
unique_Data_Arri_Delay = data['Arrival Delay in Minutes'].unique().tolist()
unique_Data_Arri_Delay.sort()
print('Các giá trị có trong cột (Arrival Delay in Minutes):\n->', unique_Data_Arri_Delay, '\n---------------------\n')

# Tìm giá trị trung vị (median) để có thể chia đều số lượng các giá trị trong 2 khoảng bằng nhau
print('Giá trị trung vị của bộ dữ liệu:', np.median(unique_Data_Arri_Delay), '\n---------------------\n')

# Từ đó thì ta sẽ chia thành 2 khoảng như sau:
series_bins1 = pd.cut(data['Arrival Delay in Minutes'], [0,241,1585], labels = ['0-240', '241-1584'], right = False)

# Thay thế giá trị của cột 'Arrival Delay in Minutes' thành giá trị vừa phân khoảng
data['Arrival Delay in Minutes'] = series_bins1
print('Ta có được bảng dữ liệu mới:')
display(data)

"""## Phân thành 2 khoảng của cột Departure Delay in Minutes:"""

# kiểm tra dao động của thời gian delay khi khách hàng đánh giá là 'satisfied'

print('Khoảng thời gian khởi hành bị dời ít nhất đối với các khách hàng hài lòng:', df['Departure Delay in Minutes'].min())
print('Khoảng thời gian khởi hành bị dời nhiều nhất đối với các khách hàng hài lòng:', df['Departure Delay in Minutes'].max())

# kiểm tra dao động của thời gian delay khi khách hàng đánh giá là 'dissatisfied'

print('Khoảng thời gian khởi hành bị dời ít nhất đối với các khách hàng không hài lòng:', df1['Departure Delay in Minutes'].min())
print('Khoảng thời gian khởi hành bị dời nhiều nhất đối với các khách hàng không hài lòng:', df1['Departure Delay in Minutes'].max())

# Đếm xem đánh giá của KH 'satisfied' khi không bị delay thời gian cất cánh

print('Sự hài lòng của KH khi chuyến bay cất cánh không bị delay:',
      df[df['Departure Delay in Minutes']==0].shape[0])

# Đếm xem đánh giá của KH 'dissatisfied' khi không bị delay thời gian cất cánh

print('Sự không hài lòng của KH khi chuyến bay cất cánh không bị delay:',
      df1[df1['Departure Delay in Minutes']==0].shape[0])

# Biểu đồ thể hiển mức độ đánh giá của KH khi chuyến bay không bị delay

x = ['satisfied', 'dissatisfied']
y = [df[df['Departure Delay in Minutes']==0].shape[0], df1[df1['Departure Delay in Minutes']==0].shape[0]]
sbn.barplot(x, y)
plt.title('Biểu đồ đánh giá sự hài lòng của KH\n khi thời gian cất cánh không bị delay', color = 'red', fontsize=16)
plt.show()

# Từ biểu đồ trên, nhóm thấy được: nếu thời gian delay dưới 4 tiếng KH sẽ ít dissatisfied hơn
# Nếu nhóm chia thành 2 khoảng từ 0-240 (đơn vị phút) và lớn hơn 241
# Lọc xem trong cột 'Arrival Delay in Minutes' có bao nhiêu giá trị chính
unique_Data_Departure_Delay = data['Departure Delay in Minutes'].unique().tolist()
unique_Data_Departure_Delay.sort()
print('Các giá trị có trong cột (Departure Delay in Minutes):\n->', unique_Data_Departure_Delay, '\n---------------------\n')

# Tìm giá trị trung vị (median) để có thể chia đều số lượng các giá trị trong 2 khoảng bằng nhau
print('Giá trị trung vị của bộ dữ liệu:', np.median(unique_Data_Departure_Delay), '\n---------------------\n')

# Từ đó thì ta sẽ chia thành 2 khoảng như sau:
series_bins2 = pd.cut(data['Departure Delay in Minutes'], [0,241,1593], labels = ['0-240', '241-1592'],  right = False)

# Thay thế giá trị của cột 'Departure Delay in Minutes' thành giá trị vừa phân khoảng
data['Departure Delay in Minutes'] = series_bins2
print('Ta có được bảng dữ liệu mới:')
display(data)

"""## Phân thành các khoảng của cột Age:"""

# Dùng hàm qcut để các khoảng sẽ tự chia đều
series_bins3 = pd.qcut(data['Age'], 4, labels = ["7-27", "28-40", "41-51", "52-85"])
data['Age'] = series_bins3
data.rename(columns = {'Age':'Age Group'},inplace = True)

print('Ta có được bảng dữ liệu mới:')
display(data)

"""## Xử lí thang đo Likert

Bộ dữ liệu đang quan sát có tổng cộng 13 biến thuộc kiểu dữ liệu định tính, sử dụng thang đo Likert với mức độ từ 1-5 (không hài lòng - rất hài lòng). Tuy nhiên, trong bộ dữ liệu có xuất hiện giá trị 0, đây không phải là giá trị thể hiện mức độ hài lòng của khách hàng về từng tiêu chí đánh giá mà là thể hiện khách hàng không có đánh giá tiêu chí đó (not rated). Nếu không xử lí giá trị 0 này thì khi tiến hành phân lớp, phân cụm sẽ gây ra hiểu lầm 0 cũng là 1 điểm đánh giá, và từ đó có thể làm sai lệch kết quả phân tích, khiến kết quả bị mâu thuẫn, phi logic.

Vì thế, ta sẽ xem 0 là dữ liệu bị thiếu. Nhóm quyết định sử dụng phương pháp thay thế dữ liệu bị thiếu này bằng 1 giá trị cụ thể, ở đây sẽ thay 0 thành 3. Nhóm chọn số 3 vì trong thang đo Likert, 3 nằm ở giữa, thể hiện thái độ bình thường, không yêu thích cũng không khó chịu, tương tự với việc khách hàng không quá coi trọng tiêu chí đánh giá đó và cảm thấy tiêu chí đó bình thường, không ảnh hưởng đến kết quả đánh giá chung về trải nghiệm bay của họ.
"""

columnsname = data.columns.tolist()

for column in range (columnsname.index('Seat comfort'), len(columnsname)-2):
   data.loc[data[columnsname[column]] == 0, columnsname[column]] = 3
display(data)

"""## phân loại biến Flight Distance"""

len(data['Flight Distance'].unique())

"""Biến Flight Distance thuộc kiểu dữ liệu liên tục, và trong bộ dữ liệu đang quan sát, biến Flight Distance có tổng cộng 5397 giá trị duy nhất. Vì thế, ta phải rời rạc hóa biến này để thuận lợi cho việc phân tích dữ liệu hơn. Sau khi tìm hiểu, trong lĩnh vực hàng không, độ dài đường bay được chia thành 3 loại: đường bay ngắn, đường bay trung bình và đường bay dài. Cụ thể:
*   Đường bay ngắn có độ dài dưới 600-800 nmi (hoặc dưới 1,1100 - 1,500 km)
*   Đường bay dài có độ dài từ 2,200 - 2,600 nmi (hoặc từ 4,100 - 4,800 km)
* Đường bay trung bình nằm giữa 800 - 2,200 nmi (từ 1,500 km đến 4,100 km)

Với thông tin trên, nhóm sẽ phân thành 3 khoảng cho biến Flight Distance:
* Short-haul: < 1500
* Medium-haul: 1500 <= x <= 4100
* Long-haul: > 4100

source: https://en.wikipedia.org/wiki/Flight_length
"""

bin_range_Flight_distance = [0,1500,4100,max(data['Flight Distance'])]
bin_names_Flight_distance = ['short-haul', 'medium-haul', 'long-haul']

data['Flight Distance'] = pd.cut(np.array(data['Flight Distance']),
                                 bins=bin_range_Flight_distance,
                                 labels=bin_names_Flight_distance)
data

"""# Biểu đồ phân tích trực quan hóa dữ liệu

## ANH THƯ
"""

myfield1 = data['satisfaction']
myfield2 = data['Age Group']
cross = pd.crosstab(myfield1,myfield2)
barplot = cross.plot.bar(color=[(238/255,106/255,167/255), (205/255,96/255,144/255),(139/255,58/255,98/255),(205/255,92/255,92/255)],rot=0)
plt.title('Biểu đồ thể hiện số lượng khách hàng theo nhóm tuổi cho từng mức độ đánh giá')
plt.xlabel('Satisfaction')
plt.ylabel('Counts')

"""**Nhận xét**

Mức độ hài lòng "Satisfaction" được hiển thị trên trục hoành, đối với mỗi mức độ có 4 thanh tương ứng với nhóm tuổi. Biến "Age Group" (nhóm tuổi) mang tính liên tục nên màu sắc được sử dụng theo thang màu tuần tự.

Nhìn chung khách hàng có nhóm tuổi càng lớn sẽ có xu hướng đánh giá hài lòng đối với chuyến bay. Ngược lại khách hàng có nhóm tuổi càng trẻ có đánh giá không hài lòng nhiều hơn.

Đặc biệt độ tuổi từ 41-51 có sự chênh lệch mức độ đánh giá khá lớn, cụ thể số lượng đánh giá hài lòng lớn gần gấp 2 lần đánh giá không hài lòng. Trong khi đó độ tuổi 28-40 không có sự chênh lệch nhiều về mức độ đánh giá.

## NHUNG HUỲNH

Heat map: Biểu diễn mối tương quan giữa các tiêu chí đánh giá chuyến bay
"""

list1 = list(data.columns)

plt.subplots(figsize=(15,15))
sbn.heatmap(data[list1].corr(), annot = True, cmap = plt.cm.Reds)
plt.show()

"""**Nhận xét :**


*   Tiêu chí 'Checkin service' (Dịch vụ checkin) có mối tương quan kém nhất với tất cả các tiêu chí khác.
*   Tiêu chí 'Food and Drink' (Đồ ăn và nước uống) có mối tương quan mạnh nhất với tiêu chí 'Seat Comfort' (Chỗ ngồi thoải mái) (0.67)
*   Tiêu chí 'Ease of Online booking' và 'Online support' có mối tương quan mạnh mẽ nhất với tiêu chí 'Online boarding' (0.68 và 0.67)
*   Tiêu chí 'Inflight wifi service', 'Online support', 'Ease of Online booking', 'Baggage Handling', 'Cleanliness' và 'Online boarding' có mối tương quan khá chặt chẽ với nhau (~ 0.6)

## THY
"""

target = 'satisfaction'

plt.figure(figsize = (8, 5))
plt.title('Biểu đồ thể hiện mức độ hài lòng ở các hạng vé',color = 'r')
x = 'Class'
y = target
sbn.countplot(x, hue = y, data = data)
plt.show()

"""**Nhận xét:**

Nhìn vào biểu đồ trên ta thấy được ở vé hạng Economy Plus có sự chênh lệch về mức độ hài lòng và không hài lòng của khách hàng tham gia chuyến bay không quá lớn, tương đối là như nhau (Khoảng 5000 khách). Ngược lại, ở vé hạng phổ thông (Economy Class) và vé hạng thương gia (Business Class) sự chênh lệch giữa hài lòng và không hài lòng có khác biệt lớn. Với vé hạng thương gia (Business Class) khách hàng đánh giá hài lòng rất cao (trên 40000 khách) khi tham gia các chuyến bay (gấp đôi số lượng đánh giá không hài lòng). Nhưng vé hạng phổ thông (Economy Class), khách hàng dường như không hài lòng với các dịch vụ, chưa cảm thấy thoải mái khi tham gia chuyến bay nên số lượng khách hàng đánh giá không hài chiếm số lượng rất lớn (khoảng 35000 khách).

## Thanh
"""

import plotly.express as px

fig = px.parallel_categories(data,
                             dimensions=['satisfaction', 'Flight Distance', 'Seat comfort'],
                             color = 'Seat comfort', color_continuous_scale="agsunset",
                             title='Biểu đồ thể hiện mối liên hệ giữa điểm tiêu chí chỗ ngồi thoải mái (Seat comfort) trong từng loại đường bay (Flight Distance) với sự hài lòng chung cho chuyến bay (satisfaction)',
                             width=1500, height=800)
fig.show()

"""**Nhận xét**

Việc khách hàng cảm thấy có thoải mái với chỗ ngồi trong từng loại đường bay có ảnh hưởng đến kết quả đánh giá độ hài lòng chung của khách hàng đối với cả chuyến bay:

*   Đối với chuyến bay đường ngắn:
  - Ở mức điểm 1-3, mức điểm thể hiện khách hàng không cảm thấy thoải mái với chỗ ngồi, sự thoải mái của chỗ ngồi không ảnh hưởng nhiều đến kết quả đánh giá tổng về chuyến bay. Cụ thể, tỉ lệ giữa việc khách hàng hài lòng với chuyến bay và không hài lòng với chuyến bay là xấp xỉ 50:50.
  - Trong khi đó, khi khách hàng cảm thấy chỗ ngồi thoải mái thì tỷ lệ khách hàng hài lòng với chuyến bay áp đảo so với sự không hài lòng:
      - ở mức điểm 4, tỉ lệ hài lòng : không hài lòng là khoảng 3:1;
      - ở mức điểm 5, hầu như không có khách hàng nào cảm thấy không hài lòng với chuyến bay (6000+ hài lòng : 30 không hài lòng)
  
*   Đối với chuyến bay đường trung bình:
  - Xu hướng cũng giống như chuyến bay đường ngắn, điểm số chỗ ngồi càng cao thì khách hàng thường sẽ hài lòng về chuyến bay

*   Đối với chuyến bay đường dài: việc đánh giá của khách hàng về sự hài lòng với chuyến bay phụ thuộc vào nhiều yếu tố khác, do vậy ở các điểm số 1-3 về chỗ ngồi, ta không nhìn thấy được sự liên hệ rõ ràng đến việc khách hàng hài lòng với chuyến bay; còn ở mức điểm 4-5, việc chỗ ngồi thoải mái một phần ảnh hưởng đến sự hài lòng của khách hàng với chuyến bay (hài lòng : không hài lòng ≈ 2:1)

"""

import plotly.express as px

fig = px.parallel_categories(data,
                             dimensions=['satisfaction', 'Flight Distance', 'Leg room service'],
                             color = 'Leg room service',
                             color_continuous_scale="agsunset",
                             title='Biểu đồ thể hiện mối liên hệ giữa điểm tiêu chí chỗ để chân (Leg room service) trong từng loại đường bay (Flight Distance) với sự hài lòng chung cho chuyến bay (satisfaction)',
                             width=1500, height=800
                )
fig.show()

"""**Nhận xét**

Việc khách hàng cảm thấy có thoải mái với chỗ để chân trong từng loại đường bay có ảnh hưởng đến kết quả đánh giá độ hài lòng chung của khách hàng đối với cả chuyến bay:

*   Đối với chuyến bay đường ngắn:
  - Ở mức điểm 1-3, mức điểm thể hiện khách hàng không thích dịch vụ về chỗ để chân, yếu tố chỗ để chân không ảnh hưởng nhiều đến kết quả đánh giá tổng về chuyến bay. Cụ thể, tỉ lệ giữa việc khách hàng hài lòng với chuyến bay và không hài lòng với chuyến bay là xấp xỉ 50:50.
  - Trong khi đó, khi khách hàng có thái độ tích cực với dịch vụ chỗ để chân thì tỷ lệ khách hàng hài lòng với chuyến bay áp đảo so với sự không hài lòng:
      - ở mức điểm 4, tỉ lệ hài lòng : không hài lòng là khoảng 3:1;
      - ở mức điểm 5, tỉ lệ hài lòng : không hài lòng là khoảng 8:1
  
*   Đối với chuyến bay đường trung bình:
  - Xu hướng cũng giống như chuyến bay đường ngắn, điểm số dịch vụ chỗ để chân càng cao thì khách hàng thường sẽ hài lòng về chuyến bay

*   Đối với chuyến bay đường dài: việc đánh giá của khách hàng về sự hài lòng với chuyến bay phụ thuộc vào nhiều yếu tố khác, do vậy ở các điểm số 1-3 về chỗ để chân, ta không nhìn thấy được sự liên hệ rõ ràng đến việc khách hàng hài lòng với chuyến bay; còn ở mức điểm 4-5, chất lượng dịch vụ chỗ để chân một phần ảnh hưởng đến sự hài lòng của khách hàng với chuyến bay (hài lòng : không hài lòng ≈ 2:1)

## Nhơn
"""

fig = px.sunburst(data,
                  path=["Type of Travel","satisfaction"],
                  title='Biểu đồ thể hiện sự hài lòng của hành khách đối với các loại hình du lịch'
                  )
fig.show()

"""**Nhận Xét :**

Có sự chênh lệch tỷ trọng giữa 2 loại hình Busines travel và Personal travel : 89,693 là Business travel và 40,187 là Personal travel.


*   Chênh lệch sự hài lòng đối với loại hình Personal Travel không lớn : 18,731 đánh giá hài lòng **bé hơn** 21,456 đánh giá không hài lòng  

*   Mặt khác: sự chênh lệch về mức độ hài lòng được thể hiện rõ ở loại hình Business travel với : 52,356 đánh giá hài lòng **lớn hơn** 37,337 đánh giá không hài lòng

## Tuyết Nhung
"""

# Chọn ra các cột có chứa thang đo từ 1 đến 5

lst_col = data.columns.tolist()
lst = lst_col[7:21]
lst

df = pd.DataFrame()
df['x'] = ['1','2','3','4','5']
for temp in lst:
    d1 = data[data['satisfaction']=='satisfied'].groupby(temp).count()
    df[temp] = d1['satisfaction'].values
display(df)

plt.figure(figsize=(16, 8))
colors = ['#663300','#666600','#FF00FF','#00CC99','#9966FF','#996600',
          '#FF0000','#FFCC00','#00CC00','#FF9900','#0066FF','#CC0066',
         '#663366','#003399']
for index, temp in enumerate(lst):
    plt.plot(df['x'], df[temp],marker='o',label=temp,color=colors[index])
plt.title('Biểu đồ thể hiện số lượng đánh giá trong khoảng [0-5] mà KH satisfied', color='r', fontsize=16)
plt.xlabel('Rating score')
plt.ylabel('Number of customers')
plt.legend()
plt.show()

"""**Nhận xét:**
- Khi KH đánh giá hãng máy báy đó là 'satisfied' thì các dịch vụ của hãng bay đó phải được đánh giá trên 3 sao là chiến ưu thế.
- Có thể KH chọn 'satisfied' và có một vài đánh giá dịch vụ là 1 2 sao, nhưng nó không nhiều
- Số lượng đánh giá các dịch vụ 1-2 sao là gần như nhau và rất thấp
"""

df_ = pd.DataFrame()
df_['x'] = ['1','2','3','4','5']
for temp in lst:
    d1 = data[data['satisfaction']=='dissatisfied'].groupby(temp).count()
    df_[temp] = d1['satisfaction'].values
df_

plt.figure(figsize=(16, 8))
colors = ['#663300','#666600','#FF00FF','#00CC99','#9966FF','#996600',
          '#FF0000','#FFCC00','#00CC00','#FF9900','#0066FF','#CC0066',
         '#663366','#003399']
for index, temp in enumerate(lst):
    plt.plot(df_['x'], df_[temp],marker='o',label=temp,color=colors[index])
plt.title('Biểu đồ thể hiện số lượng đánh giá trong khoảng [0-5] mà KH dissatisfied', color='r', fontsize=16)
plt.xlabel('Rating score')
plt.ylabel('Number of customers')
plt.legend()
plt.show()

"""**Nhận xét:**
- Ngược lại với 'satisfied', thì 'dissatisfied' có số lượng KH đánh giá 5 sao ở các dịch vụ là thấp nhất
- Các dịch vụ được KH đánh giá là 'dissatisfied' thì sẽ được KH đánh giá nhiều nhất là 3 sao trở xuống

# Chuyển đổi dữ liệu phân loại thành dạng số
"""

mapping_satisfaction = {"satisfied": 1 , "dissatisfied": 0}
data['satisfaction'] = data['satisfaction'].map(mapping_satisfaction)

mapping_gender = {"Male": 1 , "Female": 0}
data['Gender'] = data['Gender'].map(mapping_gender)

mapping_customer_type = {"Loyal Customer": 1 , "disloyal Customer": 0}
data['Customer Type'] = data['Customer Type'].map(mapping_customer_type)

mapping_type_of_travel = {"Business travel": 1, "Personal Travel": 0}
data['Type of Travel'] = data['Type of Travel'].map(mapping_type_of_travel)

mapping_class = {"Business": 1 , "Eco Plus": 2 , "Eco": 3}
data['Class'] = data['Class'].map(mapping_class)

mapping_age_group = {"7-27": 1,  "28-40": 2, "41-51": 3 , "52-85": 4}
data['Age Group'] = data['Age Group'].map(mapping_age_group)

mapping_flight_distance = {"short-haul": 1 , "medium-haul": 2 , "long-haul": 3}
data['Flight Distance']  = data['Flight Distance'].map(mapping_flight_distance)

mapping_departure_delay_in_minutes ={"0-240": 1 , "241-1592": 2}
data['Departure Delay in Minutes']=data['Departure Delay in Minutes'].map(mapping_departure_delay_in_minutes)

mapping_arrival_delay_in_minutes={"0-240": 1 , "241-1584": 2}
data['Arrival Delay in Minutes']=data['Arrival Delay in Minutes'].map(mapping_arrival_delay_in_minutes)

display(data)

display(data.info())

for i in columnsname:
  if type(data[i]) != 'int64':
    data[i] = data[i].astype('int64')

list1 = list(data.columns)

plt.subplots(figsize=(15,15))
sbn.heatmap(data[list1].corr(), annot = True, fmt = ".2f")
plt.title('Biểu đồ Heatmap thể hiện hệ số tương quan giữa các biến')
plt.show()

"""# Phân lớp

## Train, test sets
"""

# Đặt biến target, feature
X = data.drop('satisfaction',axis=1).values
y = data['satisfaction'].values
# Tách dữ liệu thành tập train, tập test
X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.2, random_state = 100)


print (X_train.shape, y_train.shape)
print (X_test.shape, y_test.shape)

"""## Xây dựng mô hình

**Phân lớp bằng phương pháp K-NN Classification**

k=2 -> accuracy =89.15%

K=3 -> accuracy =89.95%

k=4 -> accuracy =89.70%
"""

k=3
model_knn=KNeighborsClassifier(n_neighbors=k)
model_knn.fit(X_train,y_train)
KNeighborsClassifier(n_neighbors=3)

yhat = model_knn.predict(X_test)
print(f'Độ chính xác ={accuracy_score(y_test,yhat)*100:.2f}%')
print(f'precision={precision_score(y_test, yhat)*100:.2f}%')
print(f'recall={recall_score(y_test, yhat)*100:.2f}%')
print(f'f1-score={f1_score(y_test, yhat)*100:.2f}%')

#ma trận nhầm lẫn
plot_confusion_matrix(model_knn, X_test, y_test,cmap=plt.cm.pink)

"""**Phân lớp bằng phương pháp Decision Tree**"""

model_dtree=DecisionTreeClassifier(criterion='entropy')
model_dtree.fit(X_train,y_train)
DecisionTreeClassifier(criterion='entropy')

yhat=model_dtree.predict(X_test)
print(f'Độ chính xác ={accuracy_score(y_test,yhat)*100:.2f}%')
print(f'precision={precision_score(y_test, yhat)*100:.2f}%')
print(f'recall={recall_score(y_test, yhat)*100:.2f}%')
print(f'f1-score={f1_score(y_test, yhat)*100:.2f}%')

#ma trận nhầm lẫn
plot_confusion_matrix(model_dtree, X_test, y_test,cmap=plt.cm.pink)

"""**Phân lớp bằng phương pháp Support Vector Machine (SVM)**"""

model_svm=svm.SVC()
model_svm.fit(X_train,y_train)

yhat = model_svm.predict(X_test)
print(f'Độ chính xác ={accuracy_score(y_test,yhat)*100:.2f}%')
print(f'precision={precision_score(y_test, yhat)*100:.2f}%')
print(f'recall={recall_score(y_test, yhat)*100:.2f}%')
print(f'f1-score={f1_score(y_test, yhat)*100:.2f}%')

#ma trận nhầm lẫn
plot_confusion_matrix(model_svm, X_test, y_test,cmap=plt.cm.pink)

"""**Phân lớp bằng phương pháp Naive Bayes**"""

from sklearn.naive_bayes import GaussianNB
model_nbayes= GaussianNB()
model_nbayes.fit(X_train,y_train)

yhat = model_nbayes.predict(X_test)
print(f'Độ chính xác ={accuracy_score(y_test,yhat)*100:.2f}%')
print(f'precision={precision_score(y_test, yhat)*100:.2f}%')
print(f'recall={recall_score(y_test, yhat)*100:.2f}%')
print(f'f1-score={f1_score(y_test, yhat)*100:.2f}%')

#ma trận nhầm lẫn
plot_confusion_matrix(model_nbayes, X_test, y_test,cmap=plt.cm.pink)

"""## Đánh giá mô hình (Chọn phương pháp tốt nhất để dự báo)

Với phương pháp KNN Classification : ta chọn được số phân lớp là 3 có độ chính xác cao nhất ~91.29%.

Chỉ số trong một lần tính toán được :


1.   precision=93.65%
2.   recall=90.24%
3.   f1-score=91.92%


Với phương pháp Logistic Regression : kết quả phân lớp với độ chính xác ~84.95%.

Chỉ số trong một lần tính toán được :

1.   precision=85.61%
2.   recall=87.22%
3.   f1-score=86.41%


Với phương pháp Decision Tree : kết quả phân lớp với độ chính xác ~92.12%.

Chỉ số trong một lần tính toán được :

1.   precision=92.77%
2.   recall=92.88%
3.   f1-score=92.82%

Với phương pháp Support Vector Machine : kết quả phân lớp với Độ chính xác ~92.30%.

Chỉ số trong một lần tính toán được :

1.   precision=93.64%
2.   recall=92.22%
3.   f1-score=92.93%

Với phương pháp Naive Bayes GaussianNB  : kết quả phân lớp với Độ chính xác ~81.78%

Chỉ số trong một lần tính toán được :

1.   precision=81.99%
2.   recall=85.58%
3.   f1-score=83.75%



**Kết luận:**
Có 2 phương pháp phân lớp tối ưu là : Decision Tree và Support Vector Machine

## Áp dụng mô hình để dự báo
"""

#Chạy mô hình dự đoán 2 phương pháp
yhat_svm = model_svm.predict(X_test)
yhat_dtree = model_dtree.predict(X_test)

#Chuyển đổi dạng số sang chữ của mảng yhat
def convert(a):
  if(a==1) :
    return 'Hài lòng'
  else :
    return 'Không hài lòng'

"""**Dự báo với mô hình Decision Tree**"""

#bảng dự đoán hài lòng / không hài lòng theo mô hình phân lớp Decision Tree
for i in range(len(X_test)):
  print(X_test[i], ' -> ', convert(yhat_dtree[i]))

"""**Dự báo với mô hình SVM**"""

#bảng dự đoán hài lòng / không hài lòng theo mô hình phân lớp Support Vector Machine
for i in range(len(X_test)):
  print(X_test[i], ' -> ', convert(yhat_svm[i]))

"""**Ảnh hưởng của các biến độc lập tới biến phụ thuộc (satisfaction)**"""

feature_imp = pd.Series(model_dtree.feature_importances_, index = data.columns.values[0:22]).sort_values(ascending=False)
plt.figure(figsize=(10, 8))
sbn.barplot(x=feature_imp, y=feature_imp.index)
plt.xlabel('Mức độ')
plt.ylabel('Biến độc lập')
plt.title('Tree - Sự ảnh hưởng của các biến độc lập tới biến phụ thuộc')
plt.show()

"""# Phân cụm

## kMeans
"""

data_cluster1 = data.drop(columns = ['satisfaction', 'Arrival Delay in Minutes'])
data_cluster1

k = 2
model_kMeans = KMeans(n_clusters = k)
model_kMeans.fit(data_cluster1)

## Các clusters
labels     = model_kMeans.labels_
clustering = pd.concat([data_cluster1, pd.Series(labels, name = 'cluster')], axis = 1)
print('Số phần tử của mỗi cluster:')
print(clustering.cluster.value_counts(), '\n')

## Các trọng tâm = các vectors trong không gian 4 chiều
print(f'Tọa độ của {k} trọng tâm:')
centroids  = model_kMeans.cluster_centers_
print(centroids)

count = 0
for i in range (0,len(data)-1):
  if data.satisfaction[i] == clustering.cluster[i]:
    count += 1
print(f'Tỷ lệ dự đoán đúng khi đối chiếu với bộ dữ liệu gốc: {round(count/len(data),3)*100}%')

"""**Nhận xét**: Ở đây nhóm tính tỷ lệ phân cụm chính xác giữa kết quả sau khi phân cụm và biến target satisfaction ban đầu là 76,4%, một tỷ lệ có thể chấp nhận được"""

from sklearn.metrics import silhouette_score

# Fit the KMeans model
#
model_kMeans.fit_predict(data_cluster1)
#
# Calculate Silhoutte Score
#
score = silhouette_score(data_cluster1,model_kMeans.labels_, metric='euclidean')
#
# Print the score
#
print('Silhouetter Score: %.3f' % score)

"""**phương án 2**"""

data_cluster2 = data[['Class', 'Gate location']]

display(data_cluster2)

from yellowbrick.cluster import SilhouetteVisualizer

fig, ax = plt.subplots(2, 2, figsize=(15,8))
for i in [2, 3, 4, 5]:
    '''
    Create KMeans instance for different number of clusters
    '''
    model_kMeans = KMeans(n_clusters=i, init='k-means++', n_init=10, max_iter=100, random_state=42)
    q, mod = divmod(i, 2)
    '''
    Create SilhouetteVisualizer instance with KMeans instance
    Fit the visualizer
    '''
    visualizer = SilhouetteVisualizer(model_kMeans, colors='yellowbrick', ax=ax[q-1][mod])
    visualizer.fit(data_cluster2)

from sklearn.metrics import silhouette_score

# Fit the KMeans model
#
model_kMeans.fit_predict(data_cluster2)
#
# Calculate Silhoutte Score
#
score = silhouette_score(data_cluster2,model_kMeans.labels_, metric='euclidean')
#
# Print the score
#
print('Silhouetter Score: %.3f' % score)

k = 5
model_kMeans = KMeans(n_clusters = k)
model_kMeans.fit(data_cluster2)

## Các clusters
labels     = model_kMeans.labels_
clustering1 = pd.concat([data_cluster2, pd.Series(labels, name = 'cluster')], axis = 1)
print('Số phần tử của mỗi cluster:')
print(clustering1.cluster.value_counts(), '\n')

## Các trọng tâm = các vectors trong không gian 4 chiều
print(f'Tọa độ của {k} trọng tâm:')
centroids  = model_kMeans.cluster_centers_
print(centroids)

display(clustering1)

"""**Biểu diễn kết quả phân cụm**"""

ax = plt.axes()
ax.set_facecolor('#EBF3FF')


scatter = sbn.scatterplot(data = clustering1, x = 'Class', y = 'Gate location', hue = 'cluster', palette='Dark2_r')
plt.grid(False)
plt.legend(title="Cluster",
           loc='upper right', bbox_to_anchor=(1.25, 1))
plt.title('Kết quả phân cụm (k=5)')
plt.show()

from collections import Counter

# count the occurrences of each point
c = Counter(zip(clustering1['Class'], clustering1['Gate location'], clustering1['cluster']))
display(c)